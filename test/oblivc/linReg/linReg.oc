// Samuel Havron <havron@virginia.edu>
// https://www.github.com/samuelhavron
// MIT License
// WARNING: CURRENTLY IN DEVELOPMENT, WILL NOT SUCCESSFULLY COMPUTE DATA

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <obliv.oh>
#include "linReg.h"

// Forward declarations
void linear_regression(protocolIO *io, obliv int x[MAXN], obliv int y[MAXN], obliv int om, obliv int ob, obliv int or);
void check_input_count(protocolIO *io);
void toOblivX(protocolIO *io, obliv int ox[MAXN], int x[MAXN]);
void toOblivY(protocolIO *io, obliv int oy[MAXN], int y[MAXN]);


void linReg(void* args) {
  protocolIO *io = (protocolIO*) args;
  
  int x[MAXN];
  int y[MAXN];
  obliv int ox[MAXN];
  obliv int oy[MAXN];

  obliv int om = 0;
  obliv int ob = 0;
  obliv int or = 0;
  
  load_data(io, x, y, ocCurrentParty());
  check_input_count(io);
  toOblivX(io, ox, x);
  toOblivY(io, oy, y);
  
  linear_regression(io, ox, oy, om, ob, or); // functional as non-obliv only
}

void toOblivX(protocolIO *io, obliv int ox[MAXN], int x[MAXN]) {
 int i, res;
 printf("\nX data:\n"); // REMOVE WHEN COMPLETE
 for(i = 0; i < io->n; i++) {
  ox[i] = feedOblivInt(x[i], 1);
  revealOblivInt(&res, ox[i], 0); // REMOVE WHEN COMPLETE	
  printf("%lf\n", DESCALE(res)); // REMOVE WHEN COMPLETE
 }
}

void toOblivY(protocolIO *io, obliv int oy[MAXN], int y[MAXN]) {
 int i, res;
 printf("\nY data:\n"); // REMOVE WHEN COMPLETE
 for(i = 0; i < io->n; i++) {
  oy[i] = feedOblivInt(y[i], 2);
  revealOblivInt(&res, oy[i], 0); // REMOVE WHEN COMPLETE	
  printf("%lf\n", DESCALE(res)); // REMOVE WHEN COMPLETE
 }
}

void linear_regression(protocolIO *io, obliv int ox[MAXN], obliv int oy[MAXN], obliv int om, obliv int ob, obliv int or) {
 
  int n = io->n;
  int *x = malloc(sizeof(int) * n);
  int *y = malloc(sizeof(int) * n);
  printf("\nRead data:\n"); // NON-OBLIV COMPUTATION COMPLETE
  int i;
  for (i = 0; i < n; i++) {
   x[i] = ocBroadcastInt(io->x[i], 1);
   y[i] = ocBroadcastInt(io->y[i], 2);
   printf("x[%d]\t%lf\t", i, DESCALE(x[i]));
   printf("y[%d]\t%lf\n", i, DESCALE(y[i]));
  }

  double sumx = DESCALE(sum(x, n)); // sum of x
  double sumxx = DESCALE(dotProd(x, x, n)); // sum of each x squared
  double sumy = DESCALE(sum(y, n)); // sum of y
  double sumyy = DESCALE(dotProd(y, y, n)); // sum of each y squared
  double sumxy = DESCALE(dotProd(x, y, n)); // sum of each x * y
  
  double m, b, r;
  // Compute least-squares best fit straight line
  m = (n * sumxy - sumx * sumy) / (n * sumxx - sqr(sumx)); // slope
  b = (sumy * sumxx - (sumx * sumxy)) / (n * sumxx - sqr(sumx)); // y-intercept
  r = (sumxy - sumx * sumy / n) / sqrt((sumxx - sqr(sumx) / n) * (sumyy - sqr(sumy)/ n)); // correlation

  om = feedOblivInt(m * SCALE, 1); // these lines will not be needed once computation is obliv
  ob = feedOblivInt(b * SCALE, 1); // 1 is used since both are the same, does not matter
  or = feedOblivInt(r * SCALE, 1); //
  
  free(x);
  free(y);
  revealOblivInt(&io->m, om, 0);
  revealOblivInt(&io->b, ob, 0);
  revealOblivInt(&io->r, or, 0);
}

int sqr(int x) {
  return x * x;
}

int dotProd(int a[MAXN], int b[MAXN], int n) { // implement with obliv int and no integer overflow
  double dotProd = 0;
  int result = 0;
  int i;
  for (i = 0; i < n; i++) {
    dotProd += DESCALE(a[i]) * DESCALE(b[i]); // int overflow if not descaled
  }
  result = dotProd * SCALE;
  return result;
}

int sum(int a[MAXN], int n) {
  int sum = 0;
  int i;
  for (i = 0; i < n; i++) {
    sum += a[i];
  }
  return sum;
}

void check_input_count(protocolIO *io) {
 int nx = ocBroadcastInt(io->n, 1);
 int ny = ocBroadcastInt(io->n, 2);
 if (nx != ny) {
    printf("ERROR: Unequal amount of data points.\n");
    printf("X data points (party 1): %d\n", nx);
    printf("Y data points (party 2): %d\n", ny);
    exit(1);
  }
}